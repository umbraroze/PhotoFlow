#!/usr/bin/python
##########################################################################
# Photo Importinator III: This Time It's Python For Some Reason
##########################################################################
# (c) 2025 Rose Midford.
# Distributed under the MIT license. See the LICENSE file in parent folder
# for the full license terms.

from pathlib import Path
import struct

def get_sidecar(file:Path) -> dict:
    """Decodes a camera-specific sidecar file."""
    if file.name.upper() == 'NC_FLLST.DAT':
        return get_sidecar_nikon_file_list(file)
    return []

# Some documentation of the NC_FLLST.DAT file format can be found here:
# https://www.dpreview.com/forums/thread/4757978
# However, I don't think this entirely matches what D780 is doing.
# NOTE: The doc above says file format field isn't consistent between cameras
# TODO: This seems to work on D780, make sure this also makes sense on Z fc
# TODO: We're not decoding all file info, just the basics and the rating for now.

def get_sidecar_nikon_file_list(file:Path) -> dict:
    """Decodes the contents of the NC_FLLST.DAT file generated by Nikon cameras."""
    if file.name.upper() != 'NC_FLLST.DAT':
        raise ValueError("Tried to decode {file.name} and not a NC_FLLST.DAT file.")
    res = {}
    #print(f"Loading {file}")
    with open(file,'rb') as f:
        # Read header
        hdr_raw = f.read(16)
        model = struct.unpack('<hh',hdr_raw[0:4])[0]
        version = struct.unpack('<h',hdr_raw[4:6])[0]
        #print(f"Model: 0x{model:04x} version: 0x{version:04x}")
        # On D780 file, these appear to be in opposite order of
        # what the doc describes.
        entry_size = struct.unpack('<h',hdr_raw[8:10])[0]
        entry_count = struct.unpack('<h',hdr_raw[10:12])[0]
        #print(f"Contains {entry_count} entries of {entry_size} bytes")
        for entry_idx in range(0,entry_count):
            # Store the decoded values here
            entry = {}
            # Read the entry
            entry_raw = f.read(entry_size)
            # FIXME: This is textual bit reading. Not the most elegant, I know.
            # Extract the things as integers.
            word1 = struct.unpack('<i',entry_raw[0:4])[0]
            word2 = struct.unpack('<i',entry_raw[4:8])[0]
            # Turn the thing into 32 bit binary number strings, zero padded.
            word1 = f"{word1:032b}"
            word2 = f"{word2:032b}"
            # Grab the stuff from specified bit ranges and convert them back to
            # integers.
            entry = {
                'slot': int(word1[0:3],base=2) + 1,
                'folder': int(word1[3:13],base=2),
                'file_no': int(int(word1[13:28],base=2) / 2),
                'type': int(word1[28:],base=2),
                'rating': int(word2[24:],base=2)
            }
            # Further decode the rating
            match entry['rating']:
                case 0x7F:
                    entry['rating'] = 'TRASH'
                case 0x80:
                    del(entry['rating'])
                case 0x81:
                    entry['rating'] = 1
                case 0x82:
                    entry['rating'] = 2
                case 0x83:
                    entry['rating'] = 3
                case 0x84:
                    entry['rating'] = 4
                case 0x85:
                    entry['rating'] = 5

            filename = f"DSC_{entry['file_no']}"
            res[filename] = entry
    return res
